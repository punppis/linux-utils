#!/usr/bin/env bash

# docker-compose-update
#
# A robust Debian/Ubuntu-friendly tool to update Docker Compose stacks.
# 
# Default behavior: updates only currently running compose projects
# With --all: scans for compose files and updates all found projects
#
# Assumptions:
# - Debian/Ubuntu/Raspberry Pi environment
# - Docker Engine with docker compose plugin installed
# - Running with sufficient permissions (may need sudo for docker commands)

set -euo pipefail

# ==============================================================================
# CONFIGURATION & DEFAULTS
# ==============================================================================

# Default configuration
DEFAULT_ROOT="/opt"
DEFAULT_MAX_DEPTH=6
SCAN_MODE="running"  # "running" or "all"
DRY_RUN=false
PRUNE_MODE="end"     # "none", "end", or "each"
ROOT_DIR="$DEFAULT_ROOT"
MAX_DEPTH="$DEFAULT_MAX_DEPTH"

# Compose file patterns to search for
COMPOSE_FILE_PATTERNS=("docker-compose.yml" "docker-compose.yaml" "compose.yml" "compose.yaml")

# ==============================================================================
# HELPER FUNCTIONS
# ==============================================================================

red() {
  if [[ -t 1 ]]; then
    echo -e "\033[31m$*\033[0m" >&2
  else
    echo "$*" >&2
  fi
}

green() {
  if [[ -t 2 ]]; then
    echo -e "\033[32m$*\033[0m" >&2
  else
    echo "$*" >&2
  fi
}

yellow() {
  if [[ -t 2 ]]; then
    echo -e "\033[33m$*\033[0m" >&2
  else
    echo "$*" >&2
  fi
}

log() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
}

show_help() {
  cat <<EOF
docker-compose-update - Update Docker Compose stacks

USAGE:
    docker-compose-update [OPTIONS]

OPTIONS:
    --all               Scan for all compose files and update all projects
                        (default: update only currently running projects)
    
    --root DIR          Root directory to scan for compose files
                        (default: /opt, only used with --all)
    
    --max-depth N       Maximum directory depth to scan
                        (default: 6, only used with --all)
    
    --no-prune          Skip Docker system prune
                        (default: prune once at the end)
    
    --prune-each        Run Docker system prune after each project update
                        (default: prune once at the end)
    
    --dry-run           Print commands without executing them
    
    --help, -h          Show this help message

BEHAVIOR:
    Default mode (no --all):
        Detects currently running Docker Compose projects by inspecting
        container labels and updates only those projects.
    
    --all mode:
        Scans for compose files (docker-compose.yml, compose.yml, etc.)
        under the specified root directory and updates all found projects.
    
    For each project:
        1. Changes to the project's working directory
        2. Runs: docker compose pull
        3. Runs: docker compose up -d --force-recreate --remove-orphans
    
    Docker cleanup:
        Runs: docker system prune -a --volumes --force
        By default, this runs once at the end.
        With --prune-each, it runs after each project.
        With --no-prune, it is skipped entirely.

EXAMPLES:
    # Update only running compose projects
    docker-compose-update
    
    # Update all compose projects under /opt
    docker-compose-update --all
    
    # Update all projects under /srv with max depth 3
    docker-compose-update --all --root /srv --max-depth 3
    
    # Dry run to see what would be executed
    docker-compose-update --all --dry-run
    
    # Update running projects and prune after each
    docker-compose-update --prune-each

EOF
}

# ==============================================================================
# VALIDATION
# ==============================================================================

validate_dependencies() {
  if ! command -v docker &> /dev/null; then
    red "Error: docker is not installed or not in PATH"
    exit 1
  fi
  
  # Check for docker compose plugin (not docker-compose standalone)
  if ! docker compose version &> /dev/null; then
    red "Error: docker compose plugin is not available"
    red "Please install docker compose plugin: https://docs.docker.com/compose/install/"
    exit 1
  fi
}

# ==============================================================================
# CORE FUNCTIONS
# ==============================================================================

execute_or_print() {
  local cmd="$*"
  if [[ "$DRY_RUN" == "true" ]]; then
    yellow "[DRY-RUN] $cmd"
  else
    log "Executing: $cmd"
    eval "$cmd"
  fi
}

get_running_project_dirs() {
  # Get unique working directories from running compose containers
  # Uses the com.docker.compose.project.working_dir label
  local dirs
  dirs=$(docker ps --format '{{.Labels}}' 2>/dev/null | \
         grep -oP 'com\.docker\.compose\.project\.working_dir=\K[^,]+' | \
         sort -u || true)
  
  if [[ -z "$dirs" ]]; then
    log "No running Docker Compose projects found"
    return 1
  fi
  
  echo "$dirs"
}

find_compose_files() {
  local root="$1"
  local max_depth="$2"
  
  if [[ ! -d "$root" ]]; then
    red "Error: Root directory does not exist: $root"
    exit 1
  fi
  
  log "Scanning for compose files under $root (max depth: $max_depth)..."
  
  local find_args=(-maxdepth "$max_depth" -type f)
  local pattern_args=()
  
  # Build find expression for multiple patterns
  for i in "${!COMPOSE_FILE_PATTERNS[@]}"; do
    if [[ $i -eq 0 ]]; then
      pattern_args+=(-name "${COMPOSE_FILE_PATTERNS[$i]}")
    else
      pattern_args+=(-o -name "${COMPOSE_FILE_PATTERNS[$i]}")
    fi
  done
  
  find "$root" "${find_args[@]}" \( "${pattern_args[@]}" \) 2>/dev/null || true
}

update_project() {
  local project_dir="$1"
  
  if [[ ! -d "$project_dir" ]]; then
    red "Warning: Directory does not exist: $project_dir"
    return 1
  fi
  
  green "=========================================="
  log "Updating project in: $project_dir"
  green "=========================================="
  
  # Change to project directory to respect local context (overrides, .env, etc.)
  pushd "$project_dir" > /dev/null || {
    red "Error: Cannot change to directory: $project_dir"
    return 1
  }
  
  # Pull latest images
  execute_or_print "docker compose pull"
  
  # Recreate containers with new images
  execute_or_print "docker compose up -d --force-recreate --remove-orphans"
  
  popd > /dev/null
  
  # Prune after this project if requested
  if [[ "$PRUNE_MODE" == "each" ]]; then
    prune_docker
  fi
  
  return 0
}

prune_docker() {
  green "=========================================="
  log "Running Docker system prune..."
  green "=========================================="
  execute_or_print "docker system prune -a --volumes --force"
}

update_running_projects() {
  log "Mode: Update running compose projects"
  
  local dirs
  if ! dirs=$(get_running_project_dirs); then
    return 0
  fi
  
  local count=0
  while IFS= read -r dir; do
    if [[ -n "$dir" ]]; then
      update_project "$dir"
      count=$((count + 1))
    fi
  done <<< "$dirs"
  
  if [[ $count -eq 0 ]]; then
    log "No projects updated"
  else
    green "Updated $count project(s)"
  fi
}

update_all_projects() {
  log "Mode: Update all compose projects"
  log "Root: $ROOT_DIR"
  log "Max depth: $MAX_DEPTH"
  
  local compose_files
  compose_files=$(find_compose_files "$ROOT_DIR" "$MAX_DEPTH")
  
  if [[ -z "$compose_files" ]]; then
    log "No compose files found"
    return 0
  fi
  
  local count=0
  local dirs_seen=()
  
  while IFS= read -r compose_file; do
    if [[ -z "$compose_file" ]]; then
      continue
    fi
    
    local project_dir
    project_dir=$(dirname "$compose_file")
    
    # Skip if we've already processed this directory
    local already_seen=false
    for seen_dir in "${dirs_seen[@]}"; do
      if [[ "$seen_dir" == "$project_dir" ]]; then
        already_seen=true
        break
      fi
    done
    
    if [[ "$already_seen" == "true" ]]; then
      continue
    fi
    
    dirs_seen+=("$project_dir")
    update_project "$project_dir"
    count=$((count + 1))
  done <<< "$compose_files"
  
  if [[ $count -eq 0 ]]; then
    log "No projects updated"
  else
    green "Updated $count project(s)"
  fi
}

# ==============================================================================
# MAIN
# ==============================================================================

main() {
  # Parse command-line arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --all)
        SCAN_MODE="all"
        shift
        ;;
      --root)
        if [[ -z "${2:-}" ]]; then
          red "Error: --root requires a directory argument"
          exit 1
        fi
        ROOT_DIR="$2"
        shift 2
        ;;
      --max-depth)
        if [[ -z "${2:-}" ]]; then
          red "Error: --max-depth requires a numeric argument"
          exit 1
        fi
        if ! [[ "$2" =~ ^[0-9]+$ ]]; then
          red "Error: --max-depth must be a positive integer"
          exit 1
        fi
        MAX_DEPTH="$2"
        shift 2
        ;;
      --no-prune)
        PRUNE_MODE="none"
        shift
        ;;
      --prune-each)
        PRUNE_MODE="each"
        shift
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --help|-h)
        show_help
        exit 0
        ;;
      *)
        red "Error: Unknown option: $1"
        echo ""
        show_help
        exit 1
        ;;
    esac
  done
  
  # Validate dependencies
  validate_dependencies
  
  log "Starting docker-compose-update"
  if [[ "$DRY_RUN" == "true" ]]; then
    yellow "DRY-RUN MODE: Commands will be printed but not executed"
  fi
  
  # Update projects based on scan mode
  if [[ "$SCAN_MODE" == "all" ]]; then
    update_all_projects
  else
    update_running_projects
  fi
  
  # Final prune if requested
  if [[ "$PRUNE_MODE" == "end" ]]; then
    prune_docker
  fi
  
  green "=========================================="
  log "docker-compose-update completed successfully"
  green "=========================================="
}

main "$@"
